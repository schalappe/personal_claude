"""
Example: Reversible Alembic migration with best practices.

This example demonstrates:
- Proper revision metadata
- Reversible upgrade/downgrade methods
- Safe column additions
- Index creation
- Constraint additions
- Batch operations for SQLite compatibility
"""

# ##>: Alembic migration file header - auto-generated by Alembic.
# Revision ID: 2024_01_15_add_user_profile
# Revises: 2024_01_14_initial_schema
# Create Date: 2024-01-15 10:30:00.000000

from typing import Sequence

import sqlalchemy as sa
from alembic import op

# Revision identifiers used by Alembic
revision: str = '2024_01_15_add_user_profile'
down_revision: str | None = '2024_01_14_initial_schema'
branch_labels: str | Sequence[str] | None = None
depends_on: str | Sequence[str] | None = None


def upgrade() -> None:
    """
    Add user profile fields and preferences table.

    Changes:
    - Add profile_image_url column to users table
    - Add bio column to users table
    - Create user_preferences table
    - Add indexes for common queries
    """
    # ##>: Add new columns as nullable first for zero-downtime deployment.
    op.add_column(
        'users',
        sa.Column('profile_image_url', sa.String(500), nullable=True),
    )
    op.add_column(
        'users',
        sa.Column('bio', sa.Text(), nullable=True),
    )

    # ##>: Create new table with all constraints.
    op.create_table(
        'user_preferences',
        sa.Column('id', sa.String(36), primary_key=True),
        sa.Column(
            'user_id',
            sa.String(36),
            sa.ForeignKey('users.id', ondelete='CASCADE'),
            nullable=False,
        ),
        sa.Column('email_notifications', sa.Boolean(), default=True, nullable=False),
        sa.Column('push_notifications', sa.Boolean(), default=True, nullable=False),
        sa.Column('newsletter_subscribed', sa.Boolean(), default=False, nullable=False),
        sa.Column('theme', sa.String(20), default='system', nullable=False),
        sa.Column('language', sa.String(5), default='en', nullable=False),
        sa.Column(
            'created_at',
            sa.DateTime(timezone=True),
            server_default=sa.func.now(),
            nullable=False,
        ),
        sa.Column(
            'updated_at',
            sa.DateTime(timezone=True),
            server_default=sa.func.now(),
            nullable=False,
        ),
    )

    # ##>: Create indexes for common query patterns.
    op.create_index(
        'ix_user_preferences_user_id',
        'user_preferences',
        ['user_id'],
        unique=True,
    )

    # ##>: Add check constraint for valid theme values.
    op.create_check_constraint(
        'ck_preferences_valid_theme',
        'user_preferences',
        "theme IN ('light', 'dark', 'system')",
    )

    # ##>: Add check constraint for valid language codes.
    op.create_check_constraint(
        'ck_preferences_valid_language',
        'user_preferences',
        "language ~ '^[a-z]{2}(-[A-Z]{2})?$'",
    )


def downgrade() -> None:
    """
    Remove user profile fields and preferences table.

    Reverses all changes from upgrade().
    """
    # ##>: Drop constraints first (reverse order of creation).
    op.drop_constraint('ck_preferences_valid_language', 'user_preferences')
    op.drop_constraint('ck_preferences_valid_theme', 'user_preferences')

    # ##>: Drop indexes before table.
    op.drop_index('ix_user_preferences_user_id', 'user_preferences')

    # ##>: Drop table.
    op.drop_table('user_preferences')

    # ##>: Remove columns added to users table.
    op.drop_column('users', 'bio')
    op.drop_column('users', 'profile_image_url')


# Alternative: Migration with data transformation
def upgrade_with_data() -> None:
    """
    Example of migration that also transforms existing data.

    Use this pattern when:
    - Renaming columns
    - Splitting/merging columns
    - Converting data types
    """
    # Step 1: Add new column
    op.add_column(
        'users',
        sa.Column('full_name', sa.String(200), nullable=True),
    )

    # Step 2: Copy data from old columns
    # ##>: Use raw SQL for performance on large tables.
    op.execute("""
        UPDATE users
        SET full_name = CONCAT(first_name, ' ', last_name)
        WHERE first_name IS NOT NULL
    """)

    # Step 3: Make new column not null (after data is copied)
    op.alter_column(
        'users',
        'full_name',
        existing_type=sa.String(200),
        nullable=False,
    )

    # Step 4: Drop old columns (optional - may defer to separate migration)
    # op.drop_column('users', 'first_name')
    # op.drop_column('users', 'last_name')


# Alternative: Batch migration for large tables
def upgrade_large_table() -> None:
    """
    Example of batch migration for large tables.

    Use this pattern when:
    - Table has millions of rows
    - Need to avoid long-running transactions
    - Want to show progress
    """
    from sqlalchemy import text

    connection = op.get_bind()

    # ##>: Process in batches to avoid locking.
    batch_size = 10000
    offset = 0

    while True:
        result = connection.execute(
            text("""
                UPDATE users
                SET status = 'active'
                WHERE id IN (
                    SELECT id FROM users
                    WHERE status IS NULL
                    ORDER BY id
                    LIMIT :batch_size
                    OFFSET :offset
                )
                RETURNING id
            """),
            {'batch_size': batch_size, 'offset': offset},
        )

        updated = result.rowcount
        if updated == 0:
            break

        offset += batch_size
        print(f'Updated {offset} rows...')  # noqa: T201


# Alternative: Index creation without locking (PostgreSQL)
def upgrade_concurrent_index() -> None:
    """
    Example of creating index without locking table.

    Use CONCURRENTLY option in PostgreSQL to avoid blocking writes.
    """
    # ##!: CONCURRENTLY cannot run inside a transaction.
    op.execute('COMMIT')

    # ##>: Create index without locking the table.
    op.execute("""
        CREATE INDEX CONCURRENTLY ix_orders_created_at
        ON orders (created_at)
    """)


def downgrade_concurrent_index() -> None:
    """Drop concurrent index."""
    op.execute('COMMIT')
    op.execute('DROP INDEX CONCURRENTLY ix_orders_created_at')
